import Documentation from '@/components/documentation';
import BulletPoints from '@/components/documentation/bullet';
import Code from '@/components/documentation/code';
import Heading from '@/components/documentation/heading';
import Link from '@/components/documentation/link';
import Paragraph from '@/components/documentation/paragraph';
import Section from '@/components/documentation/section';

const Implementation = () => {
  return (
    <Documentation>
      <Section>
        <Heading>Random Number Generation</Heading>
        <Paragraph>
          For each verifiable bet, a client seed, a server seed, a nonce and a
          cursor are used as the input parameters for the{' '}
          <Link
            link="https://en.wikipedia.org/wiki/Random_number_generation"
            text="random number generation"
          />
          function. This function utilises the cryptographic hash function{' '}
          <Link link="https://en.wikipedia.org/wiki/HMAC" text="HMAC_SHA256" />
          to generate bytes which are then used as the foundation for how we
          generate provably fair random outcomes on our platform.
        </Paragraph>
        <Code>
          {`// Random number generation based on following inputs: serverSeed, clientSeed, nonce and cursor \n
function byteGenerator({ serverSeed, clientSeed, nonce, cursor }) {
  // Setup cursor variables
  let currentRound = Math.floor(cursor / 32);
  let currentRoundCursor = cursor;
  currentRoundCursor -= currentRound * 32;

  // Generate outputs until cursor requirement fullfilled
  while (true) {
    // HMAC function used to output provided inputs into bytes
    const hmac = createHmac('sha256', serverSeed);
    hmac.update(\`\${clientSeed}:\${nonce}:\${currentRound}\`);
    const buffer = hmac.digest();

    // Update cursor for next iteration of loop
    while (currentRoundCursor < 32) {
      yield Number(buffer[currentRoundCursor]);
      currentRoundCursor += 1;
    }
    currentRoundCursor = 0;
    currentRound += 1;
  }
}`}
        </Code>
      </Section>
      <Section>
        <Heading>Server Seed</Heading>
        <Paragraph>
          The server seed is generated by our system as a random 64-character
          hex string. You are then provided with an encrypted hash of that
          generated server seed before you place any bets. The reason we provide
          you with the encrypted form of the server seed is to ensure that the
          un-hashed server seed cannot be changed by the casino operator, and
          that the player cannot calculate the results beforehand.
        </Paragraph>
        <Paragraph>
          To reveal the server seed from its hashed version, the seed must be
          rotated by the player, which triggers the replacement with a newly
          generated one.
        </Paragraph>
        <Paragraph>
          From this point you are able to verify that the hashed server seed
          matches that of the un-hashed server seed. This process can be
          verified via our un-hashed server seed function found in the menu
          above.
        </Paragraph>
      </Section>
      <Section>
        <Heading>Client Seed</Heading>
        <Paragraph>
          The client seed belongs to the player and is used to ensure they have
          influence on the randomness of the outcomes generated. Without this
          component of the algorithm, the server seed alone would have complete
          leverage over the outcome of each bet.
        </Paragraph>
        <Paragraph>
          All players are free to edit and change their client seed regularly to
          create a new chain of random upcoming outcomes. This ensures the
          player has absolute control over the generation of the result, similar
          to cutting the deck at a brick and mortar casino.
        </Paragraph>
        <Paragraph>
          During registration, a client seed is created for you by your browser,
          to ensure your initial experience with the site goes uninterrupted.
          Whilst this randomly generated client seed is considered suitable, we
          highly recommend that you choose your own, so that your influence is
          included in the randomness.
        </Paragraph>
        <Paragraph>You can do this via the fairness modal.</Paragraph>
      </Section>
      <Section>
        <Heading>Cursor (Incremental Number)</Heading>
        <Paragraph>
          We use 4 bytes of data to generate a single game result, and because
          SHA256 is limited to 32 bytes, we utilise this implementation of a
          cursor to give us the ability to create more game events without
          having to modify our provable fair algorithm.
        </Paragraph>
        <Paragraph>
          The cursor is only iterated over when the game being played requires
          the generation of more than 8 (32 bytes / 4 bytes) possible outcomes.
          For example: when we need to use more than 8 cards in a game of
          blackjack.
        </Paragraph>
        <Paragraph>
          The cursor starts as 0 and gets increased by 1 every time the 32 bytes
          are returned by the HMAC_SHA256 function. If we donâ€™t require more
          than 8 random numbers to be generated for the game events, then the
          cursor does not increment as there is no need to generate any
          additional possible game outcomes.
        </Paragraph>
        <Paragraph>
          <span className="text-primary font-medium">
            Games with more than 1 incremental number:
          </span>
        </Paragraph>
        <BulletPoints
          bulletPoints={[
            <Paragraph>
              Keno (2 increments for every game due to 10 possible outcomes)
            </Paragraph>,
            <Paragraph>
              Mines (3 increments per game for 24 possible bomb locations)
            </Paragraph>,
            <Paragraph>
              Blackjack (Unlimited to cover required amount of cards)
            </Paragraph>,
          ]}
        />
        <Paragraph>
          <span className="text-primary font-medium">
            Games with only 1 incremental number (represented as default value
            0):
          </span>
        </Paragraph>
        <BulletPoints
          bulletPoints={[
            <Paragraph>Dice</Paragraph>,
            <Paragraph>Roulette</Paragraph>,
          ]}
        />
      </Section>
    </Documentation>
  );
};

export default Implementation;
